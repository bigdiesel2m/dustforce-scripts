const string EMBED_tile1 = "vsprites/tile1.png";
const string EMBED_tile2 = "vsprites/tile2.png";
const string EMBED_tile3 = "vsprites/tile3.png";
const string EMBED_tile4 = "vsprites/tile4.png";
const string EMBED_tile5 = "vsprites/tile5.png";
const string EMBED_door = "vsprites/door.png";
const string EMBED_cp = "vsprites/cp.png";

const string EMBED_amogus0 = "vsprites/amogus0.png";
const string EMBED_amogus1 = "vsprites/amogus1.png";
const string EMBED_coin0 = "vsprites/coin0.png";
const string EMBED_coin1 = "vsprites/coin1.png";
const string EMBED_coin2 = "vsprites/coin2.png";
const string EMBED_coin3 = "vsprites/coin3.png";
const string EMBED_heart0 = "vsprites/heart0.png";
const string EMBED_heart1 = "vsprites/heart1.png";
const string EMBED_impasta0 = "vsprites/impasta0.png";
const string EMBED_impasta1 = "vsprites/impasta1.png";
const string EMBED_lies = "vsprites/lies.png";
const string EMBED_obey = "vsprites/obey.png";
const string EMBED_soldier0 = "vsprites/soldier0.png";
const string EMBED_soldier1 = "vsprites/soldier1.png";
const string EMBED_speaker0 = "vsprites/speaker0.png";
const string EMBED_speaker1 = "vsprites/speaker1.png";
const string EMBED_stop0 = "vsprites/stop0.png";
const string EMBED_stop1 = "vsprites/stop1.png";
const string EMBED_stop2 = "vsprites/stop2.png";
const string EMBED_stop3 = "vsprites/stop3.png";
const string EMBED_truth = "vsprites/truth.png";
const string EMBED_tv = "vsprites/tv.png";
const string EMBED_yes0 = "vsprites/yes0.png";
const string EMBED_yes1 = "vsprites/yes1.png";
const string EMBED_yes2 = "vsprites/yes2.png";
const string EMBED_yes3 = "vsprites/yes3.png";

const string EMBED_spike = "vsprites/spike.png";
const string EMBED_fspike = "vsprites/fillspike.png";
const string EMBED_flipspike = "vsprites/flipspike.png";
const string EMBED_flipfspike = "vsprites/flipfillspike.png";

const string EMBED_excla = "vfont/!.png";
const string EMBED_pound = "vfont/#.png";
const string EMBED_money = "vfont/$.png";
const string EMBED_percent = "vfont/%.png";
const string EMBED_amp = "vfont/&.png";
const string EMBED_opar = "vfont/(.png";
const string EMBED_cpar = "vfont/).png";
const string EMBED_comma = "vfont/,.png";
const string EMBED_apos = "vfont/'.png";
const string EMBED_dash = "vfont/-.png";
const string EMBED_semi = "vfont/;.png";
const string EMBED_at = "vfont/@.png";
const string EMBED_obrace = "vfont/[.png";
const string EMBED_cbrace = "vfont/].png";
const string EMBED_under = "vfont/_.png";
const string EMBED_grave = "vfont/`.png";
const string EMBED_plus = "vfont/+.png";
const string EMBED_equals = "vfont/=.png";
const string EMBED_ast = "vfont/ast.png";
const string EMBED_chevl = "vfont/chevl.png";
const string EMBED_chevr = "vfont/chevr.png";
const string EMBED_colon = "vfont/colon.png";
const string EMBED_period = "vfont/period.png";
const string EMBED_quest = "vfont/quest.png";
const string EMBED_slash = "vfont/slash.png";
const string EMBED_space = "vfont/space.png";

const string EMBED_bslash = "vfont/bslash.png";

const string EMBED_0 = "vfont/0.png";
const string EMBED_1 = "vfont/1.png";
const string EMBED_2 = "vfont/2.png";
const string EMBED_3 = "vfont/3.png";
const string EMBED_4 = "vfont/4.png";
const string EMBED_5 = "vfont/5.png";
const string EMBED_6 = "vfont/6.png";
const string EMBED_7 = "vfont/7.png";
const string EMBED_8 = "vfont/8.png";
const string EMBED_9 = "vfont/9.png";

const string EMBED_A = "vfont/A.png";
const string EMBED_B = "vfont/B.png";
const string EMBED_C = "vfont/C.png";
const string EMBED_D = "vfont/D.png";
const string EMBED_E = "vfont/E.png";
const string EMBED_F = "vfont/F.png";
const string EMBED_G = "vfont/G.png";
const string EMBED_H = "vfont/H.png";
const string EMBED_I = "vfont/I.png";
const string EMBED_J = "vfont/J.png";
const string EMBED_K = "vfont/K.png";
const string EMBED_L = "vfont/L.png";
const string EMBED_M = "vfont/M.png";
const string EMBED_N = "vfont/N.png";
const string EMBED_O = "vfont/O.png";
const string EMBED_P = "vfont/P.png";
const string EMBED_Q = "vfont/Q.png";
const string EMBED_R = "vfont/R.png";
const string EMBED_S = "vfont/S.png";
const string EMBED_T = "vfont/T.png";
const string EMBED_U = "vfont/U.png";
const string EMBED_V = "vfont/V.png";
const string EMBED_W = "vfont/W.png";
const string EMBED_X = "vfont/X.png";
const string EMBED_Y = "vfont/Y.png";
const string EMBED_Z = "vfont/Z.png";

const string EMBED_a2 = "vfont/a2.png";
const string EMBED_b2 = "vfont/b2.png";
const string EMBED_c2 = "vfont/c2.png";
const string EMBED_d2 = "vfont/d2.png";
const string EMBED_e2 = "vfont/e2.png";
const string EMBED_f2 = "vfont/f2.png";
const string EMBED_g2 = "vfont/g2.png";
const string EMBED_h2 = "vfont/h2.png";
const string EMBED_i2 = "vfont/i2.png";
const string EMBED_j2 = "vfont/j2.png";
const string EMBED_k2 = "vfont/k2.png";
const string EMBED_l2 = "vfont/l2.png";
const string EMBED_m2 = "vfont/m2.png";
const string EMBED_n2 = "vfont/n2.png";
const string EMBED_o2 = "vfont/o2.png";
const string EMBED_p2 = "vfont/p2.png";
const string EMBED_q2 = "vfont/q2.png";
const string EMBED_r2 = "vfont/r2.png";
const string EMBED_s2 = "vfont/s2.png";
const string EMBED_t2 = "vfont/t2.png";
const string EMBED_u2 = "vfont/u2.png";
const string EMBED_v2 = "vfont/v2.png";
const string EMBED_w2 = "vfont/w2.png";
const string EMBED_x2 = "vfont/x2.png";
const string EMBED_y2 = "vfont/y2.png";
const string EMBED_z2 = "vfont/z2.png";

const float cam_height = 1152;
const float cam_width = 1536;
const float y_buffer = 192;
const float grid_height = cam_height + y_buffer;    

//TURNING EXISTING VARIABLES INTO INTS
const int room_width = int(cam_width/48);
const int room_height = int(grid_height/48);

const int min_grid_x = -7;
const int max_grid_x = 7;
const int min_grid_y = -9;
const int max_grid_y = 10;

class script {
    scene@ g;
    dustman@ dm;
    camera@ cam;
    canvas@ c;
    fog_setting@ fog;
    
    //TEST STUFF
    textfield@ text_test;
    int test_int = 0;
    
    //CAMERA STUFF    
    int grid_x = 0;
    int grid_y = 0;
    bool flipped = false;
    
    //TILE STUFF
    [text] array<Room> room_tiles;
    [boolean] bool build_mirrors = false;
    bool streams_resized = false;

    sprites@ spr;
    
    //PARTICLE STUFF
    array<Particle> particles_far(25);
    array<Particle> particles_mid(25);
    array<Particle> particles_near(15);
    int step_far = 0;
    int step_mid = 0;
    int step_near = 0;

    //DEATH STUFF
    float respawn_x;
    float respawn_y;
    bool was_dead = false;
    bool dying = false;
    int dying_step = 0;
    float dead_x = 0;
    float dead_y = 0;

    uint32 regular_color = 0xFF4B4BF3;

    int previous_room = -1;
    
    
    script() {
        @g = get_scene();
        @c = create_canvas(true, 0, 0);
    
        //TILE STUFF
        @spr = create_sprites();
        
        //TEST STUFF
        @text_test = @create_textfield();
        text_test.set_font("Caracteres", 26);
        text_test.align_horizontal(-1);
        text_test.align_vertical(1);
    }
    
    
    void build_sprites(message@ msg) {
        msg.set_string("tile1", "tile1");
        msg.set_string("tile2", "tile2");
        msg.set_string("tile3", "tile3");
        msg.set_string("tile4", "tile4");
        msg.set_string("tile5", "tile5");
        msg.set_string("door", "door");
        msg.set_string("cp", "cp");
        
        msg.set_string("amogus0", "amogus0");
        msg.set_string("amogus1", "amogus1");
        msg.set_string("coin0", "coin0");
        msg.set_string("coin1", "coin1");
        msg.set_string("coin2", "coin2");
        msg.set_string("coin3", "coin3");
        msg.set_string("heart0", "heart0");
        msg.set_string("heart1", "heart1");
        msg.set_string("impasta0", "impasta0");
        msg.set_string("impasta1", "impasta1");
        msg.set_string("lies", "lies");
        msg.set_string("obey", "obey");
        msg.set_string("soldier0", "soldier0");
        msg.set_string("soldier1", "soldier1");
        msg.set_string("soldier1|offsetx", "2");
        msg.set_string("speaker0", "speaker0");
        msg.set_string("speaker1", "speaker1");
        msg.set_string("stop0", "stop0");
        msg.set_string("stop1", "stop1");
        msg.set_string("stop2", "stop2");
        msg.set_string("stop3", "stop3");
        msg.set_string("truth", "truth");
        msg.set_string("tv", "tv");
        msg.set_string("yes0", "yes0");
        msg.set_string("yes1", "yes1");
        msg.set_string("yes2", "yes2");
        msg.set_string("yes3", "yes3");

        msg.set_string("spike", "spike");
        msg.set_string("fspike", "fspike");
        msg.set_string("flipspike", "flipspike");
        msg.set_string("flipfspike", "flipfspike");

        msg.set_string("!", "excla");
        msg.set_string("#", "pound");
        msg.set_string("$", "money");
        msg.set_string("%", "percent");
        msg.set_string("&", "amp");
        msg.set_string("(", "opar");
        msg.set_string(")", "cpar");
        msg.set_string(",", "comma");
        msg.set_string("'", "apos");
        msg.set_string("-", "dash");
        msg.set_string(";", "semi");
        msg.set_string("@", "at");
        msg.set_string("[", "obrace");
        msg.set_string("]", "cbrace");
        msg.set_string("_", "under");
        msg.set_string("`", "grave");
        msg.set_string("+", "plus");
        msg.set_string("=", "equals");
        msg.set_string("*", "ast");
        msg.set_string("<", "chevl");
        msg.set_string(">", "chevr");
        msg.set_string(":", "colon");
        msg.set_string(".", "period");
        msg.set_string("?", "quest");
        msg.set_string("/", "slash");
        msg.set_string(" ", "space");
        
        msg.set_string("\\", "bslash");

        msg.set_string("0", "0");
        msg.set_string("1", "1");
        msg.set_string("2", "2");
        msg.set_string("3", "3");
        msg.set_string("4", "4");
        msg.set_string("5", "5");
        msg.set_string("6", "6");
        msg.set_string("7", "7");
        msg.set_string("8", "8");
        msg.set_string("9", "9");

        msg.set_string("A", "A");
        msg.set_string("B", "B");
        msg.set_string("C", "C");
        msg.set_string("D", "D");
        msg.set_string("E", "E");
        msg.set_string("F", "F");
        msg.set_string("G", "G");
        msg.set_string("H", "H");
        msg.set_string("I", "I");
        msg.set_string("J", "J");
        msg.set_string("K", "K");
        msg.set_string("L", "L");
        msg.set_string("M", "M");
        msg.set_string("N", "N");
        msg.set_string("O", "O");
        msg.set_string("P", "P");
        msg.set_string("Q", "Q");
        msg.set_string("R", "R");
        msg.set_string("S", "S");
        msg.set_string("T", "T");
        msg.set_string("U", "U");
        msg.set_string("V", "V");
        msg.set_string("W", "W");
        msg.set_string("X", "X");
        msg.set_string("Y", "Y");
        msg.set_string("Z", "Z");

        msg.set_string("a", "a2");
        msg.set_string("b", "b2");
        msg.set_string("c", "c2");
        msg.set_string("d", "d2");
        msg.set_string("e", "e2");
        msg.set_string("f", "f2");
        msg.set_string("g", "g2");
        msg.set_string("h", "h2");
        msg.set_string("i", "i2");
        msg.set_string("j", "j2");
        msg.set_string("k", "k2");
        msg.set_string("l", "l2");
        msg.set_string("m", "m2");
        msg.set_string("n", "n2");
        msg.set_string("o", "o2");
        msg.set_string("p", "p2");
        msg.set_string("q", "q2");
        msg.set_string("r", "r2");
        msg.set_string("s", "s2");
        msg.set_string("t", "t2");
        msg.set_string("u", "u2");
        msg.set_string("v", "v2");
        msg.set_string("w", "w2");
        msg.set_string("x", "x2");
        msg.set_string("y", "y2");
        msg.set_string("z", "z2");
    }
    
    
    void step(int entities) {
        screen_transition();
        check_flip();
        particle_step();
        modify_controls();
        death_step();
        gridcheck();
        
        int current_room = get_current_room();
        if (current_room != previous_room)
            room_tiles[current_room].enter();
        previous_room = current_room;
        room_tiles[current_room].step(@this, @cam, @dm, @fog, spr, flipped);
        
    }
    
    
    int get_current_room() {
        return int(floor(((max_grid_y - min_grid_y + 1)*(grid_x - min_grid_x) + (grid_y - min_grid_y))/2));
    }
    
    
    void screen_transition() {
        //Y TELEPORTING
        if (dm.y() > cam.y() + cam_height/2 + 48) {
            if (!flipped) {
                dm.y(dm.y() + (cam_height + 2*y_buffer));
            } else {
                dm.y(dm.y() - (3*cam_height + 2*y_buffer));
            }
        } else if (dm.y() < cam.y() - cam_height/2 + 48) {
            if (!flipped) {
                dm.y(dm.y() - (cam_height + 2*y_buffer));
            } else {
                dm.y(dm.y() + (3*cam_height + 2*y_buffer));
            }
        }
    }
    
    
    void check_flip() {
        //FLIP HANDLING
        if (dm.jump_intent() != 0) {
            if (dm.ground() && !dying) {
                float y_offset = dm.y() - cam.y();
                if(!flipped) {
                    dm.y(cam.y() - grid_height - y_offset + 48 + 48);
                } else {
                    dm.y(cam.y() + grid_height - y_offset + 48 + 48);
                }
                dm.set_speed_xy(dm.x_speed(), 840);
            }
            dm.jump_intent(0);
        }
    }
    
    
    void particle_step() {
        //PARTICLE STUFF
        for(uint i = 0; i < particles_far.length; i++) {
            particles_far[i].step();
        }
        for(uint i = 0; i < particles_mid.length; i++) {
            particles_mid[i].step();
        }
        for(uint i = 0; i < particles_near.length; i++) {
            particles_near[i].step();
        }
        if ((rand() % 5) == 0) {
            if (particles_far[step_far].x < cam_width / -2 - 96) {
                particles_far[step_far].restart();
                step_far = (step_far + 1) % particles_far.length;
            }
        }
        if ((rand() % 5) == 0) {
            if (particles_mid[step_mid].x < cam_width / -2 - 96) {
                particles_mid[step_mid].restart();
                step_mid = (step_mid + 1) % particles_mid.length;
            }
        }
        if ((rand() % 5) == 0) {
            if (particles_near[step_near].x < cam_width / -2 - 96) {
                particles_near[step_near].restart();
                step_near = (step_near + 1) % particles_near.length;
            }
        }
    }
    
    
    void modify_controls() {
        //CONTROL STUFF
        /*
        if(flipped) {
            dm.y_intent(-dm.y_intent());
        }
        */
        if (dm.y_intent() == -1) {
            dm.y_intent(0);
        }
        
        
        // Messed up air physics
        /*
        if (!dm.ground()) {
            dm.di_speed(2000 * 20);
            dm.di_move_max(400 * 3);
            dm.run_start(300 * 3);
            dm.land_fric(1728 * 3);
            dm.skid_fric(1152 * 20);
            dm.idle_fric(1728 * 3);
            dm.dash(0);
        } else {
            dm.di_speed(2000);
            dm.di_move_max(400);
            dm.run_start(300);
            dm.land_fric(1728);
            dm.skid_fric(1152);
            dm.idle_fric(1728);
        }
        */
        
        // Alternate air physics 
        float y_speed = dm.y_speed();
        if(!dm.ground()) {
            dm.dash(0);
            if(y_speed < 600)
                y_speed = 600;
            else if(y_speed > 1700)
                y_speed = 1700;
        }
        dm.set_speed_xy(dm.x_intent()*700, y_speed);
        
    }
    

    void death_step() {
        //DEATH STUFF
        if (dm.dead() == true && was_dead == false) {
            dying = true;
            dm.freeze_frame_timer(500);
        }

        if (dying) {
            switch (dying_step % 6) {
                case 0:
                case 1:
                    fog.colour(18, 10, 0xFFAB1908);
                    fog.percent(18, 10, 1);
                    cam.change_fog(@fog, 0);
                    break;
                case 2:
                case 3:
                    fog.colour(18, 10, 0xFFD11C08);
                    fog.percent(18, 10, 1);
                    cam.change_fog(@fog, 0);
                    break;
                case 4:
                case 5:
                    fog.colour(18, 10, 0xFF9C1708);
                    fog.percent(18, 10, 1);
                    cam.change_fog(@fog, 0);
                    break;
            }
            dying_step++;
        }

        if (dying_step > 47) {
            dying = false;
            dm.dead(false);
            dm.freeze_frame_timer(0);
            dying_step = 0;
            dm.x(respawn_x);
            dm.y(respawn_y);
            dm.prev_x(respawn_x);
            dm.prev_y(respawn_y);
            fog.colour(18, 10, regular_color);
            fog.percent(18, 10, 1);
            cam.change_fog(@fog, 0);
            dm.set_speed_xy(0, 0);
        }
        was_dead = dm.dead();
    }
    
    
    void set_checkpoint(float x, float y) {
        respawn_x = x + 42;
        respawn_y = y;
    }
    
    
    void draw(float subframe) {
        c.draw_rectangle(-805,455,-600,-455,0,0xFF000000);
        c.draw_rectangle(805,455,600,-455,0,0xFF000000);
        //THIS THIRD RECTANGLE JUST SO I CAN READ FPS
        c.draw_rectangle(805,-350,350,-455,0,0xFF000000);
        
        draw_particles();
        
        //TILE PATTERN STUFF
        int current_room = get_current_room();
        room_tiles[current_room].draw(@c, @spr, respawn_x, respawn_y, flipped);
        
        //TEST STUFF
        //text_test.text(cam.x() + " - " + (cam.x() - (48 + cam_width / 2)) + " - " + particles_far[step_far].x);
        //text_test.text(respawn_x + " - " + respawn_y);
        //c.draw_text(text_test, 0, 250, 1, 1, 0);
    }
    
    
    void draw_particles() {
        //PARTICLE STUFF
        for(uint i = 0; i < particles_far.length; i++) {
            particles_far[i].draw(@g, cam.x(), cam.y(), flipped);
        }
        for(uint i = 0; i < particles_mid.length; i++) {
            particles_mid[i].draw(@g, cam.x(), cam.y(), flipped);
        }
        for(uint i = 0; i < particles_near.length; i++) {
            particles_near[i].draw(@g, cam.x(), cam.y(), flipped);
        }
    }
    
    
    void on_level_start() {
        initialize();
        initialize_particles();
    }
    
    
    void initialize_particles() {
        for(uint i = 0; i < particles_far.length; i++) {
            particles_far[i].init(0);
        }
        for(uint i = 0; i < particles_mid.length; i++) {
            particles_mid[i].init(1);
        }
        for(uint i = 0; i < particles_near.length; i++) {
            particles_near[i].init(2);
        }
    }
    
    
    void initialize() {
        spr.add_sprite_set("script");
        //Not relevant for a nexus, but if I want to make a custom level with this script I'll make a custom HUD as well that doesn't get split by the black bar on the left
        g.disable_score_overlay(true);
        //Swaps the entity layer behind layer 17 so we can use layer 17 as fake opaqueness for layer 19
        g.reset_layer_order();
        g.swap_layer_order(17, 18);
        
        @dm = controller_entity(0).as_dustman();
        dm.auto_respawn(false);
        @cam = get_camera(0);
        @fog = cam.get_fog();

        //SET PLAYER CHARACTER COLOR
        dictionary charcolors = {
            {'dustman', 0xFF4B4BF3},
            {'dustgirl', 0xFFFB3E3E},
            {'dustkid', 0xFFCC70CA},
            {'dustworth', 0xFF60D470},
            {'vdustman', 0xFF4B4BF3},
            {'vdustgirl', 0xFFFB3E3E},
            {'vdustkid', 0xFFCC70CA},
            {'vdustworth', 0xFF60D470}
        };
        regular_color = uint32(charcolors[dm.character()]);
        fog.colour(18, 10, regular_color);
        fog.percent(18, 10, 1);
        cam.change_fog(@fog, 0);

        cam.script_camera(true);
        cam.screen_height(cam_height);
        gridcheck();
        camera_update();
        set_checkpoint(dm.x(), dm.y());
    }
    
    
    void gridcheck() {
        //CAMERA STUFF
        int old_grid_x = grid_x;
        int old_grid_y = grid_y;
        grid_x = int(floor((dm.x() + (cam_width/2)) / cam_width));
        grid_y = int(floor((dm.y() + grid_height/2) / grid_height));
        if (old_grid_x != grid_x || old_grid_y != grid_y) {
            camera_update();
        }
        
        //SKYHAWK'S CODE TO FIX RESIZING ISSUES
        float _, height;
        cam.get_layer_draw_rect(0, 19, _, _, _, height);
        if(not closeTo(height, cam_height, 0.001)) {
            if(cam.script_camera()) {
                reset_camera(0);
                cam.script_camera(false);
            }
            cam.screen_height(cam_height);
            camera_update();
        }
        else if(not cam.script_camera()){
            cam.script_camera(true);
            camera_update();
        }
    }
    
    
    void camera_update() {
        cam.prev_x(grid_x * cam_width);
        cam.x(grid_x * cam_width);
        cam.prev_y(grid_y * grid_height);
        cam.y(grid_y * grid_height);
        if (grid_y %2 == 0) {
            flipped = false;
            cam.prev_scale_y(1);
            cam.scale_y(1);
        } else {
            flipped = true;
            cam.prev_scale_y(-1);
            cam.scale_y(-1);
        }
    }
    
    
    void editor_step() {
        if (build_mirrors) {
            if (streams_resized) {            
                build_rooms();
                build_mirrors = false;
                editor_sync_vars_menu();
                streams_resized = false;
                g.override_stream_sizes(32, 8);
            } else {
                streams_resized = true;
                g.override_stream_sizes(64, 32);
            }
        } else {
            streams_resized = false;
            g.override_stream_sizes(32, 8);
        }
    }
    
    
    void editor_draw(float sub_frame) {
        uint i = 0;

        for(int gx = min_grid_x; gx <= max_grid_x; gx++) {
            for(int gy = min_grid_y; gy <= max_grid_y; gy++) {
                float x1 =  gx * cam_width - (cam_width/2);
                float x2 =  gx * cam_width + (cam_width/2);
                float y1 =  gy * grid_height - (grid_height/2);
                float y2 =  gy * grid_height + (grid_height/2);
                float y3 =  gy * grid_height - (cam_height/2);
                float y4 =  gy * grid_height + (cam_height/2);

                g.draw_line_world(20, 20, x1, y1, x2, y1, 5, 0xFFFFFFFF);
                g.draw_line_world(20, 20, x1, y2, x2, y2, 5, 0xFFFFFFFF);
                g.draw_line_world(20, 20, x1, y3, x2, y3, 5, 0xFFFFFFFF);
                g.draw_line_world(20, 20, x1, y4, x2, y4, 5, 0xFFFFFFFF);
                g.draw_line_world(20, 20, x1, y1, x1, y2, 5, 0xFFFFFFFF);
                g.draw_line_world(20, 20, x2, y1, x2, y2, 5, 0xFFFFFFFF);
                if ((abs(gy+1) % 2) == 1) {
                    text_test.text(formatInt(i));
                    text_test.draw_world(20, 1, x1 + 20, y3 + 80, 2, 2, 0);
                    i++;
                }
            }
        }
    }
    
    
    void build_rooms() {
        Room room;
        
        room_tiles.resize(0);
        for(int gx = min_grid_x; gx <= max_grid_x; gx++) {
            for(int gy = min_grid_y + 1; gy <= max_grid_y; gy+=2) {
                room = Room();
                
                room.set_grid_coords(gx, gy);
                room.build_mirror();
                room.detect_entities();
                
                room_tiles.insertLast(room);
            }
        }
    }
}

class Room {
    [hidden] int y_coord = 0;
    [hidden] int x_coord = 0;
    [text|tooltip:"Hue angle, from 0 to 359"] int hue = 30;
    [option,0:0,1:1,2:2,3:3,4:4,5:5] int pattern = 3;
    [option,0:0,1:1,2:2,3:3,4:4,5:5] int bg_pattern = 5;
    [text] string name = "";
    
    array<Pos> tiles;
    array<Pos> bg_tiles;
    
    [text] array<Pos> triggers;
    [hidden] array<Enemy> enemies;
    
    bool tiles_generated = false;
    
    scene@ g;
    float blinki = 0;
    
    uint32 tile_rgb = 0;
    uint32 edge_rgb = 0;
    uint32 body_rgb = 0;
    uint32 bg_tile_rgb = 0;
    uint32 bg_edge_rgb = 0;
    uint32 enemy_rgb = 0;
    
    uint32 get_tile_rgb() {
        if(tile_rgb == 0) {
            tile_rgb = hsv_to_rgb(hue, .50, .70);
        }
        return tile_rgb;
    }
    
    uint32 get_edge_rgb() {
        if(edge_rgb == 0) {
            edge_rgb = hsv_to_rgb(hue, .40, .90);
        }
        return edge_rgb;
    }
    
    uint32 get_body_rgb() {
        if(body_rgb == 0) {
            body_rgb = hsv_to_rgb(hue, .50, .50);
        }
        return body_rgb;
    }
    
    uint32 get_bg_tile_rgb() {
        if(bg_tile_rgb == 0) {
            bg_tile_rgb = hsv_to_rgb(hue, .47, .13);
        }
        return bg_tile_rgb;
    }
    
    uint32 get_bg_edge_rgb() {
        if(bg_edge_rgb == 0) {
            bg_edge_rgb = hsv_to_rgb(hue, .52, .27);
        }
        return bg_edge_rgb;
    }
    
    uint32 get_enemy_rgb() {
        if(enemy_rgb == 0) {
            enemy_rgb = hsv_to_rgb(hue, 1, 1);
        }
        return enemy_rgb;
    }

    void set_grid_coords(int gx, int gy) {
        x_coord = gx;
        y_coord = gy;
    }
    
    void detect_tiles() {
        Pos@ p;
        
        //clear existing tile data
        tiles.resize(0);
        bg_tiles.resize(0);
        
        //TILE DETECTION AND STORAGE
        for(int tx = 0; tx < room_width; tx++) {
            for(int ty = 0; ty < room_height; ty++) {
                @p = build_pos(tx, ty, 19);
                if(@p != null)
                    tiles.insertLast(p);
                    
                @p = build_pos(tx, ty, 15);
                if(@p != null)
                    bg_tiles.insertLast(p);
            }
        }
    }
    
    private Pos@ build_pos(int tx, int ty, int layer) {
        int tile_x = x_coord * room_width - (room_width/2) + tx;
        int tile_y = y_coord * room_height - (room_height/2) + ty;
        tileinfo@ t = g.get_tile(tile_x, tile_y, layer);
        Pos@ p = null;
        
        if(t.solid()) {
            int tile_edges = (t.edge_top() & 8) + (t.edge_bottom() & 8)/2 + (t.edge_left() & 8)/4 + (t.edge_right() & 8)/8;
            @p = @Pos(tile_x, tile_y, tile_edges);
        }
        
        return @p;
    }
    
    void build_mirror() {
        for(int tx = 0; tx < room_width; tx++) {
            for(int ty = 0; ty < room_height; ty++) {
                // building mirrored room
                mirror_tile(tx, ty, 19);
                mirror_tile(tx, ty, 15);
            }
        }
    }
    
    private void mirror_tile(int tx, int ty, int layer) {
        int tile_x = x_coord * room_width - (room_width/2) + tx;
        int tile_y = y_coord * room_height - (room_height/2) + ty;
        int mirror_y = y_coord * room_height - (room_height/2) - ty - 1;
        uint8 edge_temp;
        tileinfo@ t = g.get_tile(tile_x, tile_y, layer);
        
        // doesnt properly mirror shapes
        if(t.solid()) {
            edge_temp = t.edge_top();
            t.edge_top(t.edge_bottom());
            t.edge_bottom(edge_temp);
        }
        g.set_tile(tile_x, mirror_y, layer, @t, false);
    }
    
    void detect_entities() {
        triggers.resize(0);
        enemies.resize(0);
        
        //DOOR AND ENEMY DETECTION AND STORAGE
        int doorint = g.get_entity_collision(y_coord * grid_height - (3*grid_height/2), y_coord * grid_height + (grid_height/2), x_coord * cam_width - cam_width/2, x_coord * cam_width + cam_width/2, 16);
        for(int j=0; j < doorint; j++) {
            entity@ CurrentEntity = g.get_entity_collision_index(j);
            if (CurrentEntity.type_name() == "level_door") {
                if (CurrentEntity.y() > y_coord * grid_height - grid_height/2) {
                    Pos p = Pos(int(6*round(CurrentEntity.x()/6)),int(6*round(CurrentEntity.y()/6)), 0);
                    triggers.insertLast(p);
                } else {
                    Pos p = Pos(int(6*round(CurrentEntity.x()/6)),int(6*round((2*(y_coord * grid_height - grid_height/2) - CurrentEntity.y())/6)), 1);
                    triggers.insertLast(p);
                }
            } else if (CurrentEntity.type_name() == "z_script_trigger") {
                scripttrigger@ s = CurrentEntity.as_scripttrigger();
                if (@s == null)
                    continue;

                if (s.type_name() == "EnemyPlacer") {
                    EnemyPlacer@ ep = cast<EnemyPlacer>(s.get_object());
                    Enemy@ e = Enemy();
                    
                    if(@ep == null) {
                        puts("Error! Null EnemyPlacer in room (" + x_coord + ", " + y_coord + ")");
                        continue;
                    }
                    
                    e.start_x = ep.start_x;
                    e.start_y = ep.start_y;
                    
                    e.end_x = ep.end_x;
                    e.end_y = ep.end_y;
                    e.duration = ep.move_duration;
                    e.repeat = ep.repeat;
                    e.reverse = ep.reverse_at_end;
                    e.sprite = ep.sprite;
                    e.frames = ep.sprite_frames;
                    e.speed = ep.animation_speed;
                    e.dont_inherit_hue = ep.dont_inherit_hue;
                    
                    enemies.insertLast(e);
                } else if (s.type_name() == "CheckPlacer") {
                    if (CurrentEntity.y() > y_coord * grid_height - grid_height/2) {
                        Pos p = Pos(int(6*round(CurrentEntity.x()/6)),int(6*round(CurrentEntity.y()/6)), 2);
                        triggers.insertLast(p);
                    } else {
                        Pos p = Pos(int(6*round(CurrentEntity.x()/6)),int(6*round((2*(y_coord * grid_height - grid_height/2) - CurrentEntity.y())/6)), 3);
                        triggers.insertLast(p);
                    }
                }
            }
        }
    }
    
    void step(script@ s, camera@ cam, dustman@ dm, fog_setting@ fog, sprites@ spr, bool flipped) {
        fog.colour(19, 10, body_rgb);
        fog.percent(19, 10, 1);
        cam.change_fog(@fog, 0);
        if (@dm != null) {
            for (uint i = 0; i < enemies.length(); i++) {
                enemies[i].step(spr, dm, y_coord, flipped);
            }
            for (uint i = 0; i < triggers.length(); i++) {
                if (triggers[i].e == 2 || triggers[i].e == 3) {
                    step_check(s, @triggers[i], dm, spr, flipped);
                }
            }
        }
        blinki += 0.25;
        if (blinki > 2) {
            blinki -= 2;
        }
    }

    void step_check(script@ s, Pos@ p, dustman@ dm, sprites@ spr, bool flipped) {
        int room_ht = cam_height + y_buffer;
        int midy = (y_coord * room_ht) - room_ht/2;
        bool colliding;
        //GETS RECTANGLES FOR DUSTMAN AND THE CHECKPOINT
        rectangle @coll = spr.get_sprite_rect("cp", 0);
        rectangle @ccoll = dm.hit_rectangle();

        //CHECKS IF THE TWO RECTANGLES ARE COLLIDING
		//flipped = p.e == 3 ? flipped : !flipped;
        if (flipped) {
            colliding = !(dm.x() + ccoll.right() < coll.left() + p.x ||
                     dm.x() + ccoll.left() > coll.right() + p.x ||
                     dm.y() + ccoll.bottom() < -coll.bottom() + (2*midy - p.y) + 97 ||
                     dm.y() + ccoll.top() > -coll.top() + (2*midy - p.y) + 97);
        } else {
            colliding = !(dm.x() + ccoll.right() < coll.left() + p.x ||
                     dm.x() + ccoll.left() > coll.right() + p.x ||
                     dm.y() + ccoll.bottom() < coll.top() + p.y - 97 ||
                     dm.y() + ccoll.top() > coll.bottom() + p.y - 97);
        }

        //IF THEY'RE COLLIDING, SET RESPAWN VALUE TO THAT CHECKPOINT'S POSITION, DEPENDING ON WHETHER IT'S RIGHTSIDE UP OR NOT
        if (colliding) {
            if (p.e == 2) {
                s.set_checkpoint(p.x, p.y);
            } else if (p.e == 3) {
                s.set_checkpoint(p.x, (2*midy - p.y));
            }
        }
    }
    
    void enter() {
        if(not tiles_generated) {
            detect_tiles();
            tiles_generated = true;
        }
        
        for (uint i = 0; i < enemies.length(); i++) {
            enemies[i].reset();
        }
    }
    
    void draw(canvas@ c, sprites@ spr, float respawn_x, float respawn_y, bool flipped) {
        draw_tile_pattern(@spr, tiles, pattern, get_tile_rgb(), get_edge_rgb(), 19, flipped);
        draw_tile_pattern(@spr, bg_tiles, bg_pattern, get_bg_tile_rgb(), get_bg_edge_rgb(), 15, flipped);
        draw_trigger_sprites(@spr, triggers, 18, respawn_x, respawn_y, flipped);
        draw_text_sprites(@c, @spr, name);
        draw_enemies(@spr, get_enemy_rgb(), flipped);
    }
    
    void draw_tile_pattern(sprites@ spr, array<Pos> tiles, int pattern, uint32 c_pattern, uint32 c_edge, int layer, bool flipped) {
        //FIND TILE Y VALUE MIDWAY BETWEEN FLIPPED AND NONFLIPPED VERSIONS OF THE ROOM
        int room_ht = (cam_height + y_buffer) / 48;
        int midy = (y_coord * room_ht) - room_ht/2;
        for(uint i = 0; i < tiles.length; i++) {
            //PATTERN DRAWING
            if (pattern != 0) {
                if (!flipped) {
                    spr.draw_world(layer, 19, "tile"+pattern, 0, 0, 48*tiles[i].x - 1, 48*tiles[i].y, 0, 0.50, 0.50, c_pattern);
                } else {
                    spr.draw_world(layer, 19, "tile"+pattern, 0, 0, 48*tiles[i].x - 1, 48*(2*midy - tiles[i].y), 0, 0.50, -0.50, c_pattern);
                }
            }
            
            //EDGE DRAWING
            int horizontal_left = 48*tiles[i].x;
            int horizontal_right = 48*tiles[i].x + 48;
            if (!flipped) {
                if (tiles[i].e & 2 > 0) { //LEFT
                    g.draw_rectangle_world(layer, 20, 48*tiles[i].x - 1, 48*tiles[i].y - 1, 48*tiles[i].x + 12, 48*tiles[i].y + 49, 0, c_edge);
                } else {
                    horizontal_left = horizontal_left - 12;
                }
                if (tiles[i].e & 1 > 0) { //RIGHT
                    g.draw_rectangle_world(layer, 20, 48*tiles[i].x + 49, 48*tiles[i].y - 1, 48*tiles[i].x + 36, 48*tiles[i].y + 49, 0, c_edge);
                } else {
                    horizontal_right = horizontal_right + 12;
                }
                if (tiles[i].e & 8 > 0) {
                    g.draw_rectangle_world(layer, 20, horizontal_left, 48*tiles[i].y -1, horizontal_right, 48*tiles[i].y + 12, 0, c_edge);
                }
                if (tiles[i].e & 4 > 0) {
                    g.draw_rectangle_world(layer, 20, horizontal_left, 48*tiles[i].y + 49, horizontal_right, 48*tiles[i].y + 36, 0, c_edge);
                }
            } else {
                if (tiles[i].e & 2 > 0) { //LEFT
                    g.draw_rectangle_world(layer, 20, 48*tiles[i].x - 1, 48*(2*midy - tiles[i].y) - 49, 48*tiles[i].x + 12, 48*(2*midy - tiles[i].y) + 1, 0, c_edge);
                } else {
                    horizontal_left = horizontal_left - 12;
                }
                if (tiles[i].e & 1 > 0) { //RIGHT
                    g.draw_rectangle_world(layer, 20, 48*tiles[i].x + 49, 48*(2*midy - tiles[i].y) - 49, 48*tiles[i].x + 36, 48*(2*midy - tiles[i].y) + 1, 0, c_edge);
                } else {
                    horizontal_right = horizontal_right + 12;
                }
                if (tiles[i].e & 8 > 0) {
                    g.draw_rectangle_world(layer, 20, horizontal_left, 48*(2*midy - tiles[i].y) - 12, horizontal_right, 48*(2*midy - tiles[i].y) + 1, 0, c_edge);
                }
                if (tiles[i].e & 4 > 0) {
                    g.draw_rectangle_world(layer, 20, horizontal_left, 48*(2*midy - tiles[i].y) - 36, horizontal_right, 48*(2*midy - tiles[i].y) - 49, 0, c_edge);
                }
            }
        }
    }

    void draw_trigger_sprites(sprites@ spr, array<Pos> triggers, int layer, float respawn_x, float respawn_y, bool flipped) {
        int room_ht = cam_height + y_buffer;
        int midy = (y_coord * room_ht) - room_ht/2;
        for(uint i = 0; i < triggers.length; i++) {
            bool is_respawn_checkpoint = triggers[i].x + 42 == respawn_x &&
                ((2 * midy - triggers[i].y) == respawn_y || triggers[i].y == respawn_y);
            uint32 door_flash_col = is_respawn_checkpoint ? 0xFFFFFFFF : 0xFFA6A6A6;
            uint32 door_unflash_col = is_respawn_checkpoint ? 0xFFE0E0E0 : 0xFFA0A0A0;
            uint32 door_col = floor(blinki) == 0 ? door_unflash_col : door_flash_col;

            if (!flipped) {
                switch(triggers[i].e) {
                    case 0:
                        spr.draw_world(layer, 0, "door", 0, 0, triggers[i].x - 36, triggers[i].y - 97, 0, 1, 1, 0xFFFFFFFF);
                        break;
                    case 1:
                        spr.draw_world(layer, 0, "door", 0, 0, triggers[i].x - 36, triggers[i].y + 97, 0, 1, -1, 0xFFFFFFFF);
                        break;
                    case 2:
                        spr.draw_world(layer, 0, "cp", 0, 0, triggers[i].x, triggers[i].y - 97, 0, 1, 1, door_col);
                        break;
                    case 3:
                        spr.draw_world(layer, 0, "cp", 0, 0, triggers[i].x, triggers[i].y + 97, 0, 1, -1, door_col);
                        break;
                }
            } else {
                switch(triggers[i].e) {
                    case 0:
                        spr.draw_world(layer, 0, "door", 0, 0, triggers[i].x - 36, 2*midy - triggers[i].y + 97, 0, 1, -1, 0xFFFFFFFF);
                        break;
                    case 1:
                        spr.draw_world(layer, 0, "door", 0, 0, triggers[i].x - 36, 2*midy - triggers[i].y - 97, 0, 1, 1, 0xFFFFFFFF);
                        break;
                    case 2:
                        spr.draw_world(layer, 0, "cp", 0, 0, triggers[i].x, 2*midy - triggers[i].y + 97, 0, 1, -1, door_col);
                        break;
                    case 3:
                        spr.draw_world(layer, 0, "cp", 0, 0, triggers[i].x, 2*midy - triggers[i].y - 97, 0, 1, 1, door_col);
                        break;
                }
            }
        }
    }
    
    void draw_enemies(sprites@ spr, uint32 col, bool flipped) {
        for (uint i = 0; i < enemies.length(); i++) {
            enemies[i].draw(g, spr, col, y_coord, flipped);
        }
    }

    //THIS PUTS THE ROOM NAME AT THE BOTTOM OF THE SCREEN
    void draw_text_sprites(canvas@ c, sprites@ spr, string name) {
        if (name != "") {
            c.draw_rectangle(-805,410,805,500,0,0xFF000000);
            int start = -16 * int(name.length());
            for(uint i = 0; i < name.length(); i++) {
                spr.draw_hud(20, 20, name.substr(i,1), 0, 0, start + i*32, 415, 0, 0.5, 0.5, 0xFFC4C4E3);
            }
        }
    }
    
    Room () {
        @g = get_scene();
    }
}

class Pos {
    [text] int x;
    [text] int y;
    [text] int e;

    Pos(int x, int y, int e) {
        this.x = x;
        this.y = y;
        this.e = e;
    }
    
    Pos() {
        //
    }
}

class Particle {
    [hidden] float x;
    [hidden] float y;
    [hidden] int l;
    
    
    Particle() {
        //
    }
    
    void init(int layer) {
        x = (rand() % (480 + cam_width)) - (480 + cam_width)/2;
        y = (rand() % cam_height) - cam_height/2;
        l = layer;
    }
    
    void step() {
        switch(l) {
            case 0:
                x = x - (cam_width / 140);
                break;
            case 1:
                x = x - (cam_width / 110);
                break;
            case 2:
                x = x - (cam_width / 80);
                break;
        }
    }
    
    void draw(scene@ g, float cam_x, float cam_y, bool flipped) {
        switch(l) {
            case 0:
            case 1:
                if (!flipped) {
                    g.draw_rectangle_world(14, 20, cam_x + x, cam_y + y, cam_x + x + 12, cam_y + y + 12, 0, 0xFF222222);
                } else {
                    g.draw_rectangle_world(14, 20, cam_x + x, cam_y - y, cam_x + x + 12, cam_y - y - 12, 0, 0xFF222222);
                }
                break;
            case 2:
                if (!flipped) {
                    g.draw_rectangle_world(14, 20, cam_x + x, cam_y + y, cam_x + x + 12, cam_y + y + 12, 0, 0xFF555555);
                } else {
                    g.draw_rectangle_world(14, 20, cam_x + x, cam_y - y, cam_x + x + 12, cam_y - y - 12, 0, 0xFF555555);
                }
                break;
        }
    }
    
    void restart() {
        x = cam_width / 2 + 96;
        y = (rand() % cam_height) - cam_height/2;
    }
}

string indexed_name(string name, float index, uint length) {
    if (length != 0)
        return name + formatInt(int(floor(index)));
    else
        return name;
}

class Enemy {
    [hidden] float start_x;
    [hidden] float start_y;
    [hidden] float end_x;
    [hidden] float end_y;
    [hidden] uint duration;
    [hidden] bool repeat;
    [hidden] bool reverse;
    [hidden] string sprite;
    [hidden] int frames;
    [hidden] float speed;
    [hidden] bool dont_inherit_hue;
    
    // 0: move forwards
    // 1: move backwards
    // 2: dont draw (offscreen or similar)
    uint current_state;
    float current_progress;
    float current_frame;
    
    void reset() {
        current_state = 0;
        current_progress = 0;
        current_frame = 0;
    }
    
    void step(sprites@ spr, dustman@ dm, int y_coord, bool flipped) {
        if (current_state == 2)
            return;
        if (collide_with(spr, dm, y_coord, flipped)) {
            dm.dead(true);
        }
        current_frame += speed/60;
        if (current_frame > frames) {
            current_frame -= frames;
        }
        if (current_state == 0) {
            if (duration > 0) {
                current_progress += 1.0/duration;
            }
            if (current_progress > 1) {
                if (repeat) {
                    if (reverse) {
                        current_state = 1;
                    } else {
                        current_progress = 0;
                    }
                } else {
                    current_state = 2;
                }
            }
        } else if (current_state == 1) {
            if (duration > 0) {
                current_progress -= 1.0/duration;
            }
            if (current_progress < 0) {
                current_state = 0;
            }
        }
    }
    
    bool collide_with(sprites@ spr, dustman@ dm, int y_coord, bool flipped) {
        int room_ht = cam_height + y_buffer;
        int midy = (y_coord * room_ht) - room_ht/2;
        float curr_x = start_x * (1.0 - current_progress) + end_x * current_progress;
        float curr_y;
        if (!flipped) {
            curr_y = start_y * (1.0 - current_progress) + end_y * current_progress;
        } else {
            curr_y = (2 * midy - start_y) * (1.0 - current_progress) + (2 * midy - end_y) * current_progress;
        }
        rectangle @coll = spr.get_sprite_rect(indexed_name(sprite, current_frame, frames), 0);
        rectangle @ccoll = dm.hit_rectangle();

        // give me like 4 pixels leniancy
        if (flipped) {
            return !(dm.x() + ccoll.right() - 8 < coll.left() + curr_x ||
                     dm.x() + ccoll.left() + 8 > coll.right() + curr_x ||
                     dm.y() + ccoll.bottom() - 8 < -coll.bottom() + curr_y ||
                     dm.y() + ccoll.top() + 8 > -coll.top() + curr_y);
        } else {
            return !(dm.x() + ccoll.right() - 8  < coll.left() + curr_x ||
                     dm.x() + ccoll.left() + 8 > coll.right() + curr_x ||
                     dm.y() + ccoll.bottom() - 8 < coll.top() + curr_y ||
                     dm.y() + ccoll.top() + 8 > coll.bottom() + curr_y);
        }
        
    }

    void draw(scene@ g, sprites@ spr, uint32 col, int y_coord, bool flipped) {
        int room_ht = cam_height + y_buffer;
        int midy = (y_coord * room_ht) - room_ht/2;
        float x1 = start_x;
        float x2 = end_x;
        float y1, y2;
        if (!flipped) {
            y1 = start_y;
            y2 = end_y;
        } else {
            y1 = 2 * midy - start_y;
            y2 = 2 * midy - end_y;
        }
        float y_scale = flipped ? -1 : 1;
        spr.draw_world(18, 8, indexed_name(sprite, current_frame, frames), 0, 0,
                       x1 * (1.0 - current_progress) + x2 * current_progress,
                       y1 * (1.0 - current_progress) + y2 * current_progress,
                       0, 1, y_scale, dont_inherit_hue ? 0xFFFFFFFF : col);       
    }
}

class EnemyPlacer : trigger_base {
    [position,mode:world,layer:19,y:"end_y"] float end_x;
    [hidden] float end_y;
	[boolean] bool start_at_place = true;
    [position,mode:world,layer:19,y:"start_y"] float start_x;
    [hidden] float start_y;	
    
    [boolean] bool repeat;
    [boolean] bool reverse_at_end;
    // Measured in steps
    [text] uint move_duration;
    
    [boolean] bool align_x = false;
    [boolean] bool align_y = false;
    [boolean] bool snap_to_grid = false;
    
    [text] string sprite = "";
    [text] int sprite_frames = 0;
    [boolean] bool dont_inherit_hue = false;
    // Measured in frames/second
    [text] float animation_speed = 1;
    float current_frame = 0;
    
    script@ s;
    sprites@ spr;
    scripttrigger@ self;
    
    void init(script@ s, scripttrigger@ self) {
        @spr = create_sprites();
        spr.add_sprite_set("script");
        @this.s = s;
        @this.self = @self;
        current_frame = 0;
    }
    
    void editor_step() {
		if (start_at_place) {
			start_x = self.x();
			start_y = self.y();
		}
        if (align_x) {
            end_x = start_x;
        }
        if (align_y) {
            end_y = start_y;
        }
        if (snap_to_grid) {
            self.x(round(start_x / 48) * 48);
            self.y(round(start_y / 48) * 48);
        }
        editor_sync_vars_menu();
        current_frame += animation_speed/60;
        if (current_frame > sprite_frames) {
            current_frame -= sprite_frames;
        }
    }
    
    void editor_draw(float f) {
        s.g.draw_line_world(20, 0, start_x, start_y, end_x, end_y, 2, 0xA0FFFFFF);
        spr.draw_world(20, 0, indexed_name(sprite, current_frame, sprite_frames), 0, 0, start_x, start_y, 0, 1, 1, 0xFFFFFFFF);
        spr.draw_world(20, 0, indexed_name(sprite, current_frame, sprite_frames), 0, 0, end_x, end_y, 0, 1, 1, 0x90FFFFFF);
    }
}

class CheckPlacer : trigger_base {
    [boolean] bool snap_to_grid = false;

    script@ s;
    sprites@ spr;
    scripttrigger@ self;
    
    void init(script@ s, scripttrigger@ self) {
        @spr = create_sprites();
        spr.add_sprite_set("script");
        @this.s = s;
        @this.self = @self;
    }
    
    void editor_step() {
        if (snap_to_grid) {
            self.x(round(self.x() / 6) * 6);
            self.y(round(self.y() / 6) * 6);
        }
        editor_sync_vars_menu();
    }
    
    void editor_draw(float f) {                        
        spr.draw_world(20, 0, "cp", 0, 0, self.x(), self.y() - 97, 0, 1, 1, 0xFFFFFFFF);
        spr.draw_world(20, 0, "cp", 0, 0, self.x(), self.y() + 97, 0, 1, -1, 0xFFFFFFFF);
    }
}

uint32 hsv_to_rgb(float hue, float sat, float val) {
    float c = val * sat;
    float h = hue % 360;
    float hs = (h / 60.0);
    float x = c * (1 - abs((hs % 2) - 1));
    float m = val - c;
    float rp = 0;
    float gp = 0;
    float bp = 0;
    int hi = int(floor(hs));
    switch(hi) {
        case 0:
            rp = c;
            gp = x;
            break;
        case 1:
            rp = x;
            gp = c;
            break;
        case 2:
            gp = c;
            bp = x;
            break;
        case 3:
            gp = x;
            bp = c;
            break;
        case 4:
            rp = x;
            bp = c;
            break;
        case 5:
            rp = c;
            bp = x;
            break;
    }
    uint r = uint(round((rp+m)*255));
    uint g = uint(round((gp+m)*255));
    uint b = uint(round((bp+m)*255));
    uint32 rgb = 0xFF000000 + (r << 16) + (g << 8) + b;
    return 0xFF000000 + (r << 16) + (g << 8) + b;
}